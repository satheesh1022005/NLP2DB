import React, { useEffect, useRef, useState } from "react";
import Mermaid from "react-mermaid2";
import ExecuteSQL from "./ExecuteSQL";
import "./style.css";
import {
  exportComponentAsPNG,
  exportComponentAsJPEG,
} from "react-component-export-image";
import svgCrowbar from "svg-crowbar";
import { saveAs } from "file-saver";
import axios from "axios";
import jsPDF from "jspdf";
const MermaidERDiagram = ({ erObject }) => {
  const [mermaidCode, setMermaidCode] = useState("");
  const diagramRef = useRef(null); // Ref for the diagram container
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [sqlQuery, setSqlQuery] = useState([]);
  const [dbName, setDbName] = useState("");
  const [dbCreationStatus, setDbCreationStatus] = useState("");
  const [viewEngine, setViewEngine] = useState(false);
  useEffect(() => {
    const generateMermaidCode = (data) => {
      let mermaidCode = "erDiagram\n";
      data.entities.forEach((entity) => {
        let entityCode = `${entity.name} {\n`;
        entity.attributes.forEach((attr) => {
          const key =
            attr.name === entity?.primaryKey
              ? "PK"
              : attr.name === entity?.foreignKey
              ? "FK"
              : "";
          entityCode += `  ${attr.type} ${attr.name} ${key}\n`;
        });
        entityCode += "}\n";
        mermaidCode += entityCode;
      });

      data.relationships.forEach((rel) => {
        let relLine = "";
        if (rel.cardinality === "many-to-one") {
          relLine = `${rel.to} ||--o{ ${rel.from} : "${rel.type}"\n`;
        } else if (rel.cardinality === "one-to-many") {
          relLine = `${rel.from} ||--o{ ${rel.to} : "${rel.type}"\n`;
        } else if (rel.cardinality === "one-to-one") {
          relLine = `${rel.from} ||--|| ${rel.to} : "${rel.type}"\n`;
        } else if (rel.cardinality === "many-to-many") {
          relLine = `${rel.from} ||--o{ ${rel.to} : "${rel.type}"\n`;
        }
        mermaidCode += relLine;
      });

      return mermaidCode;
    };

    const code = generateMermaidCode(erObject);
    setMermaidCode(code);
  }, [erObject]);

  const downloadMermaidCode = () => {
    const blob = new Blob([mermaidCode], { type: "text/plain" });
    saveAs(blob, "er-diagram.mmd");
  };
  const exportToSVG = () => {
    const svgElement = diagramRef.current.querySelector("svg");
    if (svgElement) {
      svgCrowbar(svgElement);
    }
  };
  const fetchDocumentation = async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await axios.post(
        "http://127.0.0.1:5000/generate-document",
        { er_object: erObject }
      );
      const documentText = response.data.document;
      console.log(documentText);
      // Trigger the download
      downloadTextFile(documentText, "er_documentation.txt");
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  const downloadTextFile = (text, filename) => {
    const doc = new jsPDF();
    const pageHeight = doc.internal.pageSize.height; // Get the page height
    let y = 35; // Initial Y position for text
    const lineHeight = 10; // Line height
    const footerText = "Generated by NLP2ER";
    // Set font and title formatting
    doc.setFont("Helvetica", "bold");
    doc.setFontSize(16);
    doc.text("ER Diagram Documentation", 10, 20);

    // Add a horizontal line for visual separation
    doc.setLineWidth(0.5);
    doc.line(10, 25, 200, 25);

    // Set font back to normal for the body text
    doc.setFont("Helvetica", "normal");
    doc.setFontSize(12);

    // Split the input text into multiple lines
    const lines = doc.splitTextToSize(text, 180); // 180 is the width of the text box

    lines.forEach((line) => {
      // Check if adding this line would exceed the page height
      if (y + lineHeight > pageHeight - 20) {
        // -20 for margin
        // Add a footer on the current page before creating a new page
        doc.setFontSize(10);
        doc.text(footerText, 10, pageHeight - 10);

        // Add new page and reset y position
        doc.addPage();
        y = 20; // Reset y for the next page
      }

      // Add the current line to the PDF
      doc.text(line, 10, y);
      y += lineHeight; // Move the y position down for the next line
    });

    // Add the footer on the last page
    doc.setFontSize(10);
    doc.text(footerText, 10, pageHeight - 10);

    // Save the PDF file
    doc.save(`${filename}.pdf`);
  };
  function generateCreateTableSQL(data) {
    const sqlStatements = [];

    // Mapping for data types
    const typeMapping = {
      STRING: "VARCHAR(255)", // Default length for strings
      INT: "INT",
      TEXT: "TEXT",
      DATE: "DATE",
      BOOL: "BOOLEAN",
    };

    // Loop through each entity and generate SQL for CREATE TABLE
    data.entities.forEach((entity) => {
      let sql = `CREATE TABLE ${entity.name} (\n`;

      // Add each attribute as a column in the SQL table
      entity.attributes.forEach((attr) => {
        let type = typeMapping[attr.type.toUpperCase()] || "VARCHAR(255)"; // Default to VARCHAR(255) if no mapping is found
        sql += `  ${attr.name} ${type}`;
        if (attr.name === entity.primaryKey) {
          sql += " PRIMARY KEY";
        }
        sql += ",\n";
      });

      // Remove the last comma and newline
      sql = sql.slice(0, -2) + "\n";

      sql += ");";
      sqlStatements.push(sql);
    });

    // Loop through each relationship to add foreign key constraints if necessary
    data.relationships.forEach((rel) => {
      const fromEntity = data.entities.find((e) => e.name === rel.from);
      const toEntity = data.entities.find((e) => e.name === rel.to);

      if (fromEntity && toEntity) {
        const fkName = `${rel.from}_${rel.to}_fk`;
        const fkColumn = `${rel.from}Id`;
        const refColumn = toEntity.primaryKey;

        // Generate ALTER TABLE statement for the foreign key constraint
        const fkSql = `
          ALTER TABLE ${rel.from}
          ADD CONSTRAINT ${fkName}
          FOREIGN KEY (${fkColumn}) REFERENCES ${toEntity.name}(${refColumn});
        `;
        sqlStatements.push(fkSql.trim());
      }
    });

    console.log(sqlStatements); // For debugging
    return sqlStatements;
  }

  const createDB = async () => {
    const query = generateCreateTableSQL(erObject); // Generate the SQL query for creating tables
    //const dbName = "";
    try {
      // Send request to create the database and tables
      const response = await axios.post(
        "http://localhost:8080/create-database-tables",
        {
          dbName,
          queries: [query], // Assuming you only have one query for now. Modify for multiple queries if needed.
        }
      );
      // Handle successful response
      setDbCreationStatus("Database and tables created successfully!");
      setViewEngine(true);
    } catch (error) {
      // Handle error during DB creation
      setDbCreationStatus("Error creating database: " + error.message);
    }
  };
  return (
    <div>
      {mermaidCode && (
        <>
          <div
            ref={diagramRef}
            style={{ backgroundColor: "transparent" }}
            className="mermaid-main"
          >
            <Mermaid chart={mermaidCode} key={mermaidCode} />
          </div>
          <section className="mermaid-top">
            <button onClick={downloadMermaidCode}>Download Mermaid Code</button>
            <button
              onClick={() => exportComponentAsPNG(diagramRef, "er-diagram")}
            >
              Download as PNG
            </button>
            <button
              onClick={() => exportComponentAsJPEG(diagramRef, "er-diagram")}
            >
              Download as JPG
            </button>
            <button onClick={exportToSVG}>Download as SVG</button>
            <button onClick={fetchDocumentation}>
              {loading ? "Generating..." : "Document"}
            </button>
            <input
              value={dbName}
              onChange={(e) => setDbName(e.target.value)}
              type="text"
            />
            <button onClick={createDB}>create DB</button>
          </section>
          {dbCreationStatus && <p>{dbCreationStatus}</p>}
          {viewEngine && <ExecuteSQL dbName={dbName} />}
        </>
      )}
    </div>
  );
};

export default MermaidERDiagram;
